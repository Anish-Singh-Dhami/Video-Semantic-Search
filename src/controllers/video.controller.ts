import { type Request, type Response } from "express";
import { extractAudio } from "../utils/extractAudio.js";
import {
  transcribeAudio,
  type ChunkType,
  type TranscriptionResponse,
} from "../services/whisper.servicer.js";
import fs from "fs";
import {
  generateEmbeddings,
  type EmbeddingResponse,
} from "../services/embed.service.js";
import { randomUUID } from "crypto";
import {
  storeVectorPoints,
  type VectorPoint,
} from "../services/vector.service.js";

export const handleVideoUpload = async (req: Request, res: Response) => {
  let audioPath = "";
  let videoPath = "";
  try {
    if (!req.file) {
      return res.status(400).json({ error: "No video file provided" });
    }

    const { path, originalname } = req.file;
    videoPath = path;
    console.log(`ðŸŽžï¸ Received video: ${originalname}`);

    // 1ï¸âƒ£ Extract audio
    audioPath = await extractAudio(videoPath);
    console.log("ðŸŽ§ Audio extracted:", audioPath);

    // 2ï¸âƒ£ Send to Whisper
    const transcription: TranscriptionResponse = await transcribeAudio(
      audioPath
    );

    // 3ï¸âƒ£ Get chunks (going with original timestamps for now generated by Whisper)
    const chunks: ChunkType[] = transcription.chunks;

    //4ï¸âƒ£ Generate embeddings for each chunk
    const vectorEmbeddings: EmbeddingResponse[] = await generateEmbeddings(
      chunks
    );

    // 5ï¸âƒ£ Store vectors in Qdrant
    const collectionUUID = randomUUID();
    const vectorPayloads: VectorPoint[] = vectorEmbeddings.map((vec, index) => {
      return {
        id: index,
        vector: vec.embedding,
        payload: {
          text: chunks[index]?.text || "<NOT_FOUND>",
          start_time: chunks[index]?.timestamp?.start_time || -1.0,
          end_time: chunks[index]?.timestamp?.end_time || -1.0,
        },
      };
    });
    await storeVectorPoints(collectionUUID, vectorPayloads);

    res.status(200).json({
      message: "Video uploaded and indexed",
      summary: transcription.text.slice(0, 100),
      collectionId: collectionUUID,
    });
  } catch (error: any) {
    console.error("Upload Error:", error.message);
    return res.status(500).json({ error: "Internal server error" });
  } finally {
    //  Clean up files
    fs.unlinkSync(audioPath);
    fs.unlinkSync(videoPath); // optional cleanup
  }
};
